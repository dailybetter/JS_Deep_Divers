# 객체 리터럴

## 10.1 객체란?

원시 값을 제외한 나머지 값은 모두 객체다

원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value) 이지만 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.

## 10.2 객체 리터럴에 의한 객체 생성

| 인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실체를 말한다. oop에서 객체는 클래스와 인스턴스를 포함한 개념이다.

자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성방법을 지원한다.

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 매서드
- 클래스

이러한 객체 생성 방법 중에서 가장 일반적이고 간단한 방법이 리터럴을 사용하는 것이다.

## 10.3 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

```javascript
var person = {
  name: "Hyunwoo",
  //프로퍼티 키는 name, 프로퍼티 값은 'Lee'
  age: 20,
};
```

프로퍼티 키에는 빈문자열을 포함하는 모든 문자열 또는 심벌 값이 올 수 있다.
프로퍼티 키를 생성할때 가급적 식별자 네이밍 규칙을 따라야한다.

### 식별자 네이밍 규칙

1. 식별자는 대소문자를 구분합니다. 예를 들어, 변수 "name"과 "Name"은 서로 다른 식별자입니다.

2. 식별자는 문자, 숫자, 밑줄 (\_) 또는 달러 기호($)로 구성됩니다. 그러나, 숫자로 시작하는 식별자는 사용할 수 없습니다.

3. 식별자는 유니코드 문자를 사용할 수 있습니다.

4. 식별자는 예약어(reserved words)를 사용할 수 없습니다. 예를 들어, 변수 이름으로 "if", "else", "for", "function" 등을 사용할 수 없습니다.

5. 식별자는 명확하고 의미있는 이름으로 짓는 것이 좋습니다. 이는 코드의 가독성을 높이고 유지 보수를 용이하게 합니다.

6. 변수 이름은 소문자로 시작하고, 단어가 더해질 때마다 첫 글자를 대문자로 표기하여 카멜 케이스(camelCase)로 작성합니다. 예를 들어, "firstName", "lastName" 등이 있습니다.

7. 상수(constant)는 모두 대문자로 작성하며, 단어 사이에 밑줄(\_)을 넣습니다. 예를 들어, "MAX_LENGTH", "TOTAL_COUNT" 등이 있습니다.

8. 클래스 이름은 첫 글자를 대문자로 작성하며, 카멜 케이스를 사용합니다. 예를 들어, "Person", "Car" 등이 있습니다.

9. 생성자 함수(constructor)의 이름은 첫 글자를 대문자로 작성하며, 카멜 케이스를 사용합니다. 예를 들어, "Person", "Car" 등이 있습니다.

10. 함수 이름은 소문자로 작성하며, 단어가 더해질 때마다 첫 글자를 대문자로 표기하여 카멜 케이스를 사용합니다. 예를 들어, "calculateTotal", "getUserInfo" 등이 있습니다.

이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.

```javascript
let foo = {
  name: "Lee",
  name: "Park",
};
console.log(foo); // {name: 'Park'}
```

## 10.4 메서드

프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다. 즉, 메서드는 객체에 묶여 있는 함수를 의미한다.

## 10.5 프로퍼티 접근

프로퍼티에 접근하는 방법은 두가지다.

- 마침표 표기법
- 대괄호 표기법

프로퍼티키가 식별자 네이밍 규칙을 준수하는 이름, 즉 자바스크립트에서 사용 가능한 유효한 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있다.

대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 그렇지 않으면 자바스크립트 엔진은 대괄호안에 있는 키를 프로퍼티 키가 아닌 식별자로 해석하기 때문에 에러가 발생한다.

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

프로퍼티 축약 표현

```javascript
const [x, y] = [1, 2];

const obj = {
  x: x,
  y: y,
};

console.log(obj); // {x: 1, y: 2}

//---

const [hello, world] = [1, 2];

const obj = { hello, world };

console.log(obj); // {hello: 1, world: 2}
```

# 원시 값과 객체의 비교

원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.

원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달되고 이를 값에 의한 전달 pass by value 라고 한다.

이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달되고 이를 참조에 의한 전달 pass by reference 라고 한다.

## 11.1 원시 값

<img src="./img/원시 값을 가진 변수의 변경.png" alt='dd'>

원시 값을 변경할 수 없다 의 뜻은 메모리에 저장된 원시 값 자체를 변경할 수 없다는 뜻이다. 변수가 가리키던 메모리 공간의 주소를 바꿔서 변수를 변경할 수 있다.

## 11.1.2 문자열과 불변성

원시 값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 한다. 이를 위해 원시 타입별로 메모리 공간의 크기가 미리 정해져 있다. 문자열 타입(2바이트) 와 숫자 타입(8바이트) 이외의 원시 타입은 크기를 명확히 규정하고 있지는 않다.

문자열에는 유사 배열 객체라는 것이 있다. 유사 배열 객체란 **마치 배열처럼 인덱스로 프로퍼터 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.** 그리고 length가 있기 때문에 for 문을 통해서 문자열의 문자들을 조회할 수 있다. 하지만 배열은 아니므로 배열의 메서드인 push, pop, shift, unshift 등은 사용할 수 없다.

```javascript
const name = "ayaan";

console.log(name.length); // 5
console.log(name[0]); // 'a'

for (let i = 0; i < name.length; i++) {
  console.log(name[i]); // 'a', 'y', 'a', 'a', 'n'
}
```

이를 이용해 문자열읠 값을 수정할 수는 없다.

```javascript
let name = "ayaan";

name[0] = "k";

console.log(name); // undefined
```

유사 배열 객체일 경우에 배열 메서드를 사용하고 싶다면 Array.from, Array.slice, 스프레드 연산자 등 실제 배열로 변경한 후 배열 메서드를 사용하면 된다.

## 11.1.3 값에 의한 전달

```javascript
let score = 80;
let copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

copy = 100;

console.log(score === copy); // false
```

변수에 이미 할당된 값을 전달받는 것을 값에 의한 전달이라고 한다. 이때 copy는 복사된 score의 값을 전달받는 것이다. score와 copy는 값은 값을 같는건 맞지만 전혀 다른 메모리 공간에 저장된 별개의 값이다. 그렇기 때문에 copy의 값을 변경해도 score 변수에 전혀 영향을 주지 않는다.

예제의 두 값은 서로 다른 메모리 공간에 저장된 별개의 값이라는 것이며, 재할당을 통해 한 쪽에서 값을 변경해도 서로 간섭할 수 없다

## 11.2 객체

객체는 원시 값과는 다르게 0개부터 수백개의 프로퍼티 값을 가질 수도 있게 된다. 그래서 값이 매우 클 수도 있고, 원시 값 처럼 크기가 일정하지 않으며 프로퍼티 값이 객체일 수도 있어서 복사(deep copy)해서 생성하는 비용이 많이 든다. 객체를 복사해서 생성하는 부분이 메모리의 효율적 소비가 어렵고 성능이 나빠진다는 뜻이다.

## 11.2.1 변경 가능한 값

<img src="./img/객체의 할당.png" alt='dd'>

자바스크립트는 이러한 점을 보완하고자 객체를 복사해서 생성하는 비용을 절약하고, 성능을 향상시킬 수 있도록 설계했다. 바로 객체를 변경 가능한 값으로 설계한 부분이 이러한 이유때문이다. 정리하자면 원시 값은 재할당을 해서 값을 수정하지만 객체는 그렇게 하면 복잡하고 메모리 효율이 좋지 않기 때문에 재할당없이 값을 수정할 수 있도록 설계했다고 보면 된다.

객체는 이러한 구조적 단점에 따른 부작용이 있다. 그것은 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.

## {} == {} , {} === {}

```javascript
{} === {} // false
{} == {} // false
```

이 둘의 비교 값에 대해서 왜 둘 다 false일까?에 대한 개념이다. 첫번째는 바로 위에서 공부한 내용과 유사하다. person1 === person2와 같이 객체는 참조 값을 가진다. 즉 객체라는 것은 원시 값처럼 메모리 공간에 값을 가지고 있는 것이 아니라 어느 객체에 참조하고 있다는 뜻인 객체의 번지수, 즉 주소 값을 가지고 있는 것이다. 그렇기 때문에 하나의 객체는 하나의 참조 값을 가지고 있으므로, 따로 객체 리터럴을 통해 객체를 만들었다면 별개의 객체가 되는 것이다. 그래서 첫번째는 false 값을 가진다.

그렇다면 두번째는 왜 false일까? 느슨한 동등 연산자(==)는 값이 달라도 타입이 같으면 true를 반환한다. 두번째는 결국 object == object를 하고 있는 것인데 왜 false일까? 사실 객체에는 타입의 여부도 상관이 없다. 즉 객체앞에서 엄격한 연산자(===)와 느슨한 동등 연산자(==)는 차이가 없다는 뜻이다. 이 부분 또한 결국 객체는 참조 값을 가지고 있기 때문이라고 할 수 있다.

## 얕은 복사와 깊은 복사

객체에는 얕은 복사와 깊은 복사의 개념이 있다. 이러한 개념이 생긴 이유는 어떠한 값을 복사하느냐에 따라 달라지기 때문인 것 같다고 생각한다. 간단히 설명하면 얕은 복사는 참조 값을, 깊은 복사는 원시 값처럼 완전한 복사를 한다.

하지만 알아야 할 사실은 얕은 복사든 깊은 복사든 복사를 통해 생성된 객체는 원본과는 다른 객체라는 것이다. 단지 얕은 복사는 객체에 중첩되어 있는 객체일 경우 참조 값을 복사하는 것이고, 깊은 복사는 객체에 중첩되어 있는 객체까지 완전한 복사를 한다는 차이만 있을 뿐이다.
