# 4. 변수 & 5. 표현식과 문

### 4.1 변수란 무엇인가? 왜 필요한가?

- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다.
    - 변수 : 값의 위치를 가리키는 상징적인 이름
    - 할당 : 변수에 값을 저장
    - 참조 : 변수에 저장된 값을 읽어 들이는 것
- 메모리
    - 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.
        - 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다.
        - 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어들인다.
        - 각 셀은 고유의 메모리 주소를 갖는다.
        - 예를 들어 4GB 메모리는 0부터 4,294,967,295까지의 주소를 갖는다.
        - 컴퓨터는 모든 데이터를 2진수로 처리하므로, 데이터는 종류와 상관없이 2진수로 저장된다.
    
    ![Untitled](4%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20&%205%20%E1%84%91%E1%85%AD%E1%84%92%E1%85%A7%E1%86%AB%E1%84%89%E1%85%B5%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%86%E1%85%AE%E1%86%AB%203381c9cfffa0446fb7a0f3d19ef8ff0c/Untitled.png)
    

### 4.2 식별자

- 식별자 = 변수 이름
- 식별자는 값이 아니라 메모리 주소를 기억
- 식별자 = 변수 이름 = 메모리 주소에 붙인 이름

![Untitled](4%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20&%205%20%E1%84%91%E1%85%AD%E1%84%92%E1%85%A7%E1%86%AB%E1%84%89%E1%85%B5%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%86%E1%85%AE%E1%86%AB%203381c9cfffa0446fb7a0f3d19ef8ff0c/Untitled%201.png)

### 4.3 변수 선언

- 변수 선언 = 변수를 생성하는 것
    - var, let, const 키워드 사용
    - var에는 여러 단점이 있다. ⇒ 함수 레벨 스코프로 인하여 의도치 않은 전역 변수 선언
- 변수를 선언하면 변수 이름을 등록하 확보한 메모리 공간에 undefined라는 값이 암묵적으로 할당되어 초기화 됨
    - 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록됨
- 초기화 = 변수 선언 이후 최초로 값을 할당하는 것

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

```tsx
console.log(score) //undefined

var score;
```

- 참조 에러가 발생할 것 같지만 참조 에러가 발생하지 않고 undefined가 출력된다.
- **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문**
- 호이스팅 : 식별자가 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
    - var, let, const, function, class를 사용해 선언하는 모든 식별자는 호이스팅 됨

### 4.5 값의 할당

- 변수에 값을 할당 할 때는 할당 연산자 =을 사용한다.
- 변수 선언은 런타임 이전에, 값의 할당은 런타임에 실행된다.

```jsx
console.log(score); // undefined => 런타임
score = 80; // 값의 할당 => 런타임
var score; // 변수 선언 => 런타임 이전에 호이스팅으로 선언

console.log(score); // 80 => 런타임
```

### 4.6 값의 재할당

- var, let 키워드로 선언한 변수는 값을 재할당할 수 있다.
- const 키워드로 선언한 변수는 재할당이 금지된다. ⇒ 상수를 표현할 수 있다.
- 재할당 후 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 단 해제되는 시기는 예측할 수 없다.

### 4.7 식별자 네이밍 규칙

- 예약어 사용 불가
- 알파벳, 카멜 케이스, 파스칼 케이스 권장
- 변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히

---

### 5.1 값

- **값(value)은 식(표현식, expression)이 평가(evaluate)되어 생성된 결과를 말한다.**
    - 평가란 식을 해석해서 값을 생성하거나 참조하는 것
    
    ```jsx
    // 10 + 20은 평가되어 숫자 값 30을 생성한다.
    10 + 20; // 30
    ```
    
- 변수에는 값이 할당된다.
    
    ```jsx
    // 변수에는 10 + 20이 평가되어 생성된 값 30이 할당된다.
    var sum = 10 + 20;
    ```
    

### 5.2 리터럴

- 리터럴 = 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
- 문자 그대로의 값
    - ex) false = false

![Untitled](4%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20&%205%20%E1%84%91%E1%85%AD%E1%84%92%E1%85%A7%E1%86%AB%E1%84%89%E1%85%B5%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%86%E1%85%AE%E1%86%AB%203381c9cfffa0446fb7a0f3d19ef8ff0c/Untitled%202.png)

### 5.3 표현식

- 표현식 = 값으로 평가될 수 있는 문(statement)
    - 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
- **값으로 평가될 수 있는 문은 모두 표현식이다.**

```jsx
// 리터럴 표현식
10
'Hello'

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()

```

### 5.4 문(statement)

- **문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.**
    - 프로그램 = 문의 집합
    - 프로그래밍 = 문을 작성하고 순서에 맞게 나열
- 문은 여러 토큰으로 **구성**된다
    - **토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.**
        
        ![Untitled](4%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20&%205%20%E1%84%91%E1%85%AD%E1%84%92%E1%85%A7%E1%86%AB%E1%84%89%E1%85%B5%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%86%E1%85%AE%E1%86%AB%203381c9cfffa0446fb7a0f3d19ef8ff0c/Untitled%203.png)
        

```jsx
// 변수 선언문
var x;

// 할당문
x = 5;

// 함수 선언문
function foo () {}

// 조건문
if (x > 1) {console.log(x)}

// 반복문
for (var i = 0; i < 2; i ++) {console.log(i)}
```

### 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론(;)은 문의 종료를 나타낸다.
- 하지만 문의 끝에 붙이는 세미콜론은 옵션이다. 세미콜론 자동 삽입 기능이 암묵적으로 수행되기 때문이다. 하지만 간혹 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 있다.
- 때문에 세미콜론 여부에 논쟁이 있다.

### 5.6 표현식인 문과 표현식이 아닌 문

- 문에는 표현식인 문과 표현식이 아닌 문이 있다.
- 표현식인 문 = 값으로 평가될 수 있는 문
- 표현식이 아닌 문 = 값으로 평가될 수 없는 문